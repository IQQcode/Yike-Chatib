## 1. 服务端MyWebSocket属性



```java
    //打印日志信息
    private static final Logger logger = LoggerFactory.getLogger(MyWebSocket.class);

    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
    private static int onlineCount = 0;

    //与某个客户端的连接会话，需要通过它来给指定的客户端发送数据
    private Session session;

    //用以记录用户和房间号的对应关系(sessionId,room)
    private static HashMap<String,String> RoomForUser = new HashMap<String,String>();

    //用以记录房间和其中用户群的对应关系(room,List<用户>)
    public static HashMap<String, CopyOnWriteArraySet<User>> UserForRoom = new HashMap<String,CopyOnWriteArraySet<User>>();

    //用以记录房间和其中用户群的对应关系(room,List<用户>)
    public static HashMap<String,String> PwdForRoom = new HashMap<String,String>();

    //用来存放必应壁纸
    public static List<String> BingImages = new ArrayList<>();

    private Gson gson = new Gson();

    private Random random = new Random();
```

【同步问题】

1. 为了防止多用户下，房间人数`onlineCount`统计出现异常，统计人数方法**addOnlineCount**要用`synchronized`确保同步

2. 当前用户对象获取后，要放入容器中存储，保证同步放到了`CopyOnWriteArraySet`线程安全的Set中

	> [线程安全的CopyOnWrite容器](https://blog.csdn.net/linsongbin1/article/details/54581787?utm_medium=referral)
	>
	> [JAVA中的COPYONWRITE容器](https://coolshell.cn/articles/11175.html)

### 人数统计

```java
	public static synchronized int getOnlineCount() {
        return onlineCount;
    }

    public static synchronized void addOnlineCount() {
        MyWebSocket.onlineCount++;
    }

    //同房间用户下线, count--
    public static synchronized void subOnlineCount() {
        MyWebSocket.onlineCount--;
    }
```

### 上线消息广播

WebSocket session发送文本消息有两个方法：

- `getAsyncRemote()`

- `getBasicRemote() `

getAsyncRemote是 **非阻塞式** 的，getBasicRemote是**阻塞式** 的。

由于getBasicRemote()的同步特性，并且它支持部分消息的发送即`sendText`的值表示是否一次发送消息中的部分消息，对于如下情况：

```java
session.getBasicRemote().sendText(message, false); 

session.getBasicRemote().sendBinary(data);

session.getBasicRemote().sendText(message, true); 
```

由于同步特性，第二行的消息必须等待第一行的发送完成才能进行，而第一行的剩余部分消息要等第二行发送完才能继续发送，所以在第二行会抛出`IllegalStateException`异常。

如果要使用getBasicRemote()同步发送消息，则避免尽量一次发送全部消息，使用部分消息来发送。

综上所述，我采用`getBasicRemote()`同步发送消息

```java
/**
 * 上线消息广播
 * @param message
 * @throws IOException
 */
public void sendMessage(String message) throws IOException {
    this.session.getBasicRemote().sendText(message);
}
```



## 2. 客户端

服务端将广播消息推送给客户端，客户端接收到服务端推送的消息后回调`onmessage`方法

```javascript
//客户端接收到服务端推送的消息后回调方法
websocket.onmessage = function(event){
    var data = JSON.parse(event.data)
    var msg = data.msg;
    var nick = data.sendUser;
    var shakeStatus = data.shake;
    if (focus && mute%2==0) {
        playSound();
        notifyMe(data);
    }
    switch(data.type){
        case 'init':
            getOnlion(document.getElementById('room').value);
            layer.msg(msg);
            break;
        case 'msg':
            setMessageInnerHTML(nick,text2Emoji2(msg),shakeStatus);
            break;
        case 'img':
            setImgInnerHTML(nick,msg);
            break;
        case 'bing':
            document.getElementById('userId').value = data.id;
            $('body').css("background-image","url("+msg+")");
            break;
        default:
            break;
    }
}
```

